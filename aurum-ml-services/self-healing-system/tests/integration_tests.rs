use self_healing_system::*;
use tempfile::tempdir;
use std::collections::HashMap;

#[cfg(test)]
mod integration_tests {
    use super::*;

    #[test]
    fn test_end_to_end_workflow() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let config = Config {
            llm_provider: "openai".to_string(),
            openai_api_key: Some("test-key".to_string()),
            anthropic_api_key: None,
            local_model_path: None,
            max_retries: 3,
            timeout_seconds: 30,
            safety_checks: true,
            auto_approve: false,
            webhook_url: None,
            slack_webhook: None,
            discord_webhook: None,
            email_notifications: false,
            prometheus_port: 9090,
            log_level: "info".to_string(),
            database_url: format!("sqlite:{}", db_path.to_string_lossy()),
            cache_dir: dir.path().join("cache").to_string_lossy().to_string(),
            max_cache_size_mb: 100,
            rate_limit: 10,
            enable_security_scanning: true,
            enable_performance_monitoring: true,
            enable_dependency_analysis: true,
            enable_rollback: true,
            enable_notifications: true,
            enable_webhooks: true,
            enable_prometheus: true,
            enable_grafana: true,
            enable_jaeger: true,
            enable_opentelemetry: true,
            enable_docker: true,
            enable_kubernetes: true,
            enable_helm: true,
            enable_terraform: true,
            enable_ansible: true,
            enable_chef: true,
            enable_puppet: true,
            enable_salt: true,
            enable_consul: true,
            enable_vault: true,
            enable_nomad: true,
            enable_prometheus_operator: true,
            enable_grafana_operator: true,
            enable_jaeger_operator: true,
            enable_opentelemetry_operator: true,
            enable_cert_manager: true,
            enable_ingress_nginx: true,
            enable_external_dns: true,
            enable_cluster_autoscaler: true,
            enable_metrics_server: true,
            enable_vertical_pod_autoscaler: true,
            enable_horizontal_pod_autoscaler: true,
            enable_pod_disruption_budget: true,
            enable_network_policies: true,
            enable_pod_security_policies: true,
            enable_pod_security_standards: true,
            enable_gatekeeper: true,
            enable_kyverno: true,
            enable_falco: true,
            enable_trivy: true,
            enable_anchore: true,
            enable_snyk: true,
            enable_grype: true,
            enable_clair: true,
            enable_docker_bench: true,
            enable_kube_bench: true,
            enable_kube_hunter: true,
            enable_kube_audit: true,
            enable_kube_leak: true,
            enable_kube_score: true,
            enable_kube_linter: true,
            enable_kube_conform: true,
            enable_kube_val: true,
            enable_kube_no Trouble: true,
            enable_kube_psp: true,
            enable_kube_warden: true,
            enable_kube_policy: true,
            enable_kube_guard: true,
            enable_kube_falco: true,
            enable_kube_sysdig: true,
            enable_kube_prometheus: true,
            enable_kube_grafana: true,
            enable_kube_jaeger: true,
            enable_kube_opentelemetry: true,
            enable_kube_cert_manager: true,
            enable_kube_ingress: true,
            enable_kube_dns: true,
            enable_kube_autoscaler: true,
            enable_kube_metrics: true,
            enable_kube_vpa: true,
            enable_kube_hpa: true,
            enable_kube_pdb: true,
            enable_kube_network: true,
            enable_kube_security: true,
            enable_kube_gatekeeper: true,
            enable_kube_kyverno: true,
            enable_kube_falco: true,
            enable_kube_trivy: true,
            enable_kube_anchore: true,
            enable_kube_snyk: true,
            enable_kube_grype: true,
            enable_kube_clair: true,
            enable_kube_bench: true,
            enable_kube_hunter: true,
            enable_kube_audit: true,
            enable_kube_leak: true,
            enable_kube_score: true,
            enable_kube_linter: true,
            enable_kube_conform: true,
            enable_kube_val: true,
            enable_kube_no_trouble: true,
            enable_kube_psp: true,
            enable_kube_warden: true,
            enable_kube_policy: true,
            enable_kube_guard: true,
        };

        let system = SelfHealingSystem::new(config).unwrap();
        
        // Simulate a build failure
        let failure = BuildFailure {
            id: "test-failure-1".to_string(),
            timestamp: chrono::Utc::now(),
            build_id: "build-123".to_string(),
            error_type: ErrorType::Compilation,
            error_message: "error[E0308]: mismatched types".to_string(),
            affected_files: vec!["src/main.rs".to_string()],
            severity: Severity::High,
            context: HashMap::new(),
        };

        let result = system.handle_build_failure(failure);
        assert!(result.is_ok());
    }

    #[test]
    fn test_static_analysis_integration() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let config = Config {
            llm_provider: "openai".to_string(),
            openai_api_key: Some("test-key".to_string()),
            anthropic_api_key: None,
            local_model_path: None,
            max_retries: 3,
            timeout_seconds: 30,
            safety_checks: true,
            auto_approve: false,
            webhook_url: None,
            slack_webhook: None,
            discord_webhook: None,
            email_notifications: false,
            prometheus_port: 9090,
            log_level: "info".to_string(),
            database_url: format!("sqlite:{}", db_path.to_string_lossy()),
            cache_dir: dir.path().join("cache").to_string_lossy().to_string(),
            max_cache_size_mb: 100,
            rate_limit: 10,
            enable_security_scanning: true,
            enable_performance_monitoring: true,
            enable_dependency_analysis: true,
            enable_rollback: true,
            enable_notifications: true,
            enable_webhooks: true,
            enable_prometheus: true,
            enable_grafana: true,
            enable_jaeger: true,
            enable_opentelemetry: true,
            enable_docker: true,
            enable_kubernetes: true,
            enable_helm: true,
            enable_terraform: true,
            enable_ansible: true,
            enable_chef: true,
            enable_puppet: true,
            enable_salt: true,
            enable_consul: true,
            enable_vault: true,
            enable_nomad: true,
            enable_prometheus_operator: true,
            enable_grafana_operator: true,
            enable_jaeger_operator: true,
            enable_opentelemetry_operator: true,
            enable_cert_manager: true,
            enable_ingress_nginx: true,
            enable_external_dns: true,
            enable_cluster_autoscaler: true,
            enable_metrics_server: true,
            enable_vertical_pod_autoscaler: true,
            enable_horizontal_pod_autoscaler: true,
            enable_pod_disruption_budget: true,
            enable_network_policies: true,
            enable_pod_security_policies: true,
            enable_pod_security_standards: true,
            enable_gatekeeper: true,
            enable_kyverno: true,
            enable_falco: true,
            enable_trivy: true,
            enable_anchore: true,
            enable_snyk: true,
            enable_grype: true,
            enable_clair: true,
            enable_docker_bench: true,
            enable_kube_bench: true,
            enable_kube_hunter: true,
            enable_kube_audit: true,
            enable_kube_leak: true,
            enable_kube_score: true,
            enable_kube_linter: true,
            enable_kube_conform: true,
            enable_kube_val: true,
            enable_kube_no_trouble: true,
            enable_kube_psp: true,
            enable_kube_warden: true,
            enable_kube_policy: true,
            enable_kube_guard: true,
            enable_kube_falco: true,
            enable_kube_sysdig: true,
            enable_kube_prometheus: true,
            enable_kube_grafana: true,
            enable_kube_jaeger: true,
            enable_kube_opentelemetry: true,
            enable_kube_cert_manager: true,
            enable_kube_ingress: true,
            enable_kube_dns: true,
            enable_kube_autoscaler: true,
            enable_kube_metrics: true,
            enable_kube_vpa: true,
            enable_kube_hpa: true,
            enable_kube_pdb: true,
            enable_kube_network: true,
            enable_kube_security: true,
            enable_kube_gatekeeper: true,
            enable_kube_kyverno: true,
            enable_kube_falco: true,
            enable_kube_trivy: true,
            enable_kube_anchore: true,
            enable_kube_snyk: true,
            enable_kube_grype: true,
            enable_kube_clair: true,
            enable_kube_bench: true,
            enable_kube_hunter: true,
            enable_kube_audit: true,
            enable_kube_leak: true,
            enable_kube_score: true,
            enable_kube_linter: true,
            enable_kube_conform: true,
            enable_kube_val: true,
            enable_kube_no_trouble: true,
            enable_kube_psp: true,
            enable_kube_warden: true,
            enable_kube_policy: true,
            enable_kube_guard: true,
        };

        let system = SelfHealingSystem::new(config).unwrap();
        let analyzer = system.static_analyzer;
        
        let code = r#"
            fn main() {
                let x = 5;
                let y = "hello";
                println!("{} {}", x, y);
            }
        "#;
        
        let issues = analyzer.analyze_code(code, "src/main.rs");
        assert!(!issues.is_empty());
    }

    #[test]
    fn test_llm_integration() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let config = Config {
            llm_provider: "openai".to_string(),
            openai_api_key: Some("test-key".to_string()),
            anthropic_api_key: None,
            local_model_path: None,
            max_retries: 3,
            timeout_seconds: 30,
            safety_checks: true,
            auto_approve: false,
            webhook_url: None,
            slack_webhook: None,
            discord_webhook: None,
            email_notifications: false,
            prometheus_port: 9090,
            log_level: "info".to_string(),
            database_url: format!("sqlite:{}", db_path.to_string_lossy()),
            cache_dir: dir.path().join("cache").to_string_lossy().to_string(),
            max_cache_size_mb: 100,
            rate_limit: 10,
            enable_security_scanning: true,
            enable_performance_monitoring: true,
            enable_dependency_analysis: true,
            enable_rollback: true,
            enable_notifications: true,
            enable_webhooks: true,
            enable_prometheus: true,
            enable_grafana: true,
            enable_jaeger: true,
            enable_opentelemetry: true,
            enable_docker: true,
            enable_kubernetes: true,
            enable_helm: true,
            enable_terraform: true,
            enable_ansible: true,
            enable_chef: true,
            enable_puppet: true,
            enable_salt: true,
            enable_consul: true,
            enable_vault: true,
            enable_nomad: true,
            enable_prometheus_operator: true,
            enable_grafana_operator: true,
            enable_jaeger_operator: true,
            enable_opentelemetry_operator: true,
            enable_cert_manager: true,
            enable_ingress_nginx: true,
            enable_external_dns: true,
            enable_cluster_autoscaler: true,
            enable_metrics_server: true,
            enable_vertical_pod_autoscaler: true,
            enable_horizontal_pod_autoscaler: true,
            enable_pod_disruption_budget: true,
            enable_network_policies: true,
            enable_pod_security_policies: true,
            enable_pod_security_standards: true,
            enable_gatekeeper: true,
            enable_kyverno: true,
            enable_falco: true,
            enable_trivy: true,
            enable_anchore: true,
            enable_snyk: true,
            enable_grype: true,
            enable_clair: true,
            enable_docker_bench: true,
            enable_kube_bench: true,
            enable_kube_hunter: true,
            enable_kube_audit: true,
            enable_kube_leak: true,
            enable_kube_score: true,
            enable_kube_linter: true,
            enable_kube_conform: true,
            enable_kube_val: true,
            enable_kube_no_trouble: true,
            enable_kube_psp: true,
            enable_kube_warden: true,
            enable_kube_policy: true,
            enable_kube_guard: true,
        };

        let system = SelfHealingSystem::new(config).unwrap();
        let llm = system.llm_client;
        
        let prompt = "Generate a fix for a type mismatch error in Rust";
        let response = llm.generate_patch(prompt);
        
        // Mock response for testing
        assert!(response.is_ok());
    }

    #[test]
    fn test_patch_generation_workflow() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let config = Config {
            llm_provider: "openai".to_string(),
            openai_api_key: Some("test-key".to_string()),
            anthropic_api_key: None,
            local_model_path: None,
            max_retries: 3,
            timeout_seconds: 30,
            safety_checks: true,
            auto_approve: false,
            webhook_url: None,
            slack_webhook: None,
            discord_webhook: None,
            email_notifications: false,
            prometheus_port: 9090,
            log_level: "info".to_string(),
            database_url: format!("sqlite:{}", db_path.to_string_lossy()),
            cache_dir: dir.path().join("cache").to_string_lossy().to_string(),
            max_cache_size_mb: 100,
            rate_limit: 10,
            enable_security_scanning: true,
            enable_performance_monitoring: true,
            enable_dependency_analysis: true,
            enable_rollback: true,
            enable_notifications: true,
            enable_webhooks: true,
            enable_prometheus: true,
            enable_grafana: true,
            enable_jaeger: true,
            enable_opentelemetry: true,
            enable_docker: true,
            enable_kubernetes: true,
            enable_helm: true,
            enable_terraform: true,
            enable_ansible: true,
            enable_chef: true,
            enable_puppet: true,
            enable_salt: true,
            enable_consul: true,
            enable_vault: true,
            enable_nomad: true,
            enable_prometheus_operator: true,
            enable_grafana_operator: true,
            enable_jaeger_operator: true,
            enable_opentelemetry_operator: true,
            enable_cert_manager: true,
            enable_ingress_nginx: true,
            enable_external_dns: true,
            enable_cluster_autoscaler: true,
            enable_metrics_server: true,
            enable_vertical_pod_autoscaler: true,
            enable_horizontal_pod_autoscaler: true,
            enable_pod_disruption_budget: true,
            enable_network_policies: true,
            enable_pod_security_policies: true,
            enable_pod_security_standards: true,
            enable_gatekeeper: true,
            enable_kyverno: true,
            enable_falco: true,
            enable_trivy: true,
            enable_anchore: true,
            enable_snyk: true,
            enable_grype: true,
            enable_clair: true,
            enable_docker_bench: true,
            enable_kube_bench: true,
            enable_kube_hunter: true,
            enable_kube_audit: true,
            enable_kube_leak: true,
            enable_kube_score: true,
            enable_kube_linter: true,
            enable_kube_conform: true,
            enable_kube_val: true,
            enable_kube_no_trouble: true,
            enable_kube_psp: true,
            enable_kube_warden: true,
            enable_kube_policy: true,
            enable_kube_guard: true,
        };

        let system = SelfHealingSystem::new(config).unwrap();
        let generator = system.patch_generator;
        
        let failure = BuildFailure {
            id: "gen-test".to_string(),
            timestamp: chrono::Utc::now(),
            build_id: "build-456".to_string(),
            error_type: ErrorType::Compilation,
            error_message: "expected i32, found String".to_string(),
            affected_files: vec!["src/main.rs".to_string()],
            severity: Severity::Medium,
            context: HashMap::new(),
        };
        
        let patches = generator.generate_patches(&failure);
        assert!(patches.is_ok());
    }

    #[test]
    fn test_patch_validation_integration() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let config = Config {
            llm_provider: "openai".to_string(),
            openai_api_key: Some("test-key".to_string()),
            anthropic_api_key: None,
            local_model_path: None,
            max_retries: 3,
            timeout_seconds: 30,
            safety_checks: true,
            auto_approve: false,
            webhook_url: None,
            slack_webhook: None,
            discord_webhook: None,
            email_notifications: false,
            prometheus_port: 9090,
            log_level: "info".to_string(),
            database_url: format!("sqlite:{}", db_path.to_string_lossy()),
            cache_dir: dir.path().join("cache").to_string_lossy().to_string(),
            max_cache_size_mb: 100,
            rate_limit: 10,
            enable_security_scanning: true,
            enable_performance_monitoring: true,
            enable_dependency_analysis: true,
            enable_rollback: true,
            enable_notifications: true,
            enable_webhooks: true,
            enable_prometheus: true,
            enable_grafana: true,
            enable_jaeger: true,
            enable_opentelemetry: true,
            enable_docker: true,
            enable_kubernetes: true,
            enable_helm: true,
            enable_terraform: true,
            enable_ansible: true,
            enable_chef: true,
            enable_puppet: true,
            enable_salt: true,
            enable_consul: true,
            enable_vault: true,
            enable_nomad: true,
            enable_prometheus_operator: true,
            enable_grafana_operator: true,
            enable_jaeger_operator: true,
            enable_opentelemetry_operator: true,
            enable_cert_manager: true,
            enable_ingress_nginx: true,
            enable_external_dns: true,
            enable_cluster_autoscaler: true,
            enable_metrics_server: true,
            enable_vertical_pod_autoscaler: true,
            enable_horizontal_pod_autoscaler: true,
            enable_pod_disruption_budget: true,
            enable_network_policies: true,
            enable_pod_security_policies: true,
            enable_pod_security_standards: true,
            enable_gatekeeper: true,
            enable_kyverno: true,
            enable_falco: true,
            enable_trivy: true,
            enable_anchore: true,
            enable_snyk: true,
            enable_grype: true,
            enable_clair: true,
            enable_docker_bench: true,
            enable_kube_bench: true,
            enable_kube_hunter: true,
            enable_kube_audit: true,
            enable_kube_leak: true,
            enable_kube_score: true,
            enable_kube_linter: true,
            enable_kube_conform: true,
            enable_kube_val: true,
            enable_kube_no_trouble: true,
            enable_kube_psp: true,
            enable_kube_warden: true,
            enable_kube_policy: true,
            enable_kube_guard: true,
        };

        let system = SelfHealingSystem::new(config).unwrap();
        let validator = system.patch_validator;
        
        let patch = patch_generator::Patch {
            id: "validation-test".to_string(),
            target_file: "src/main.rs".to_string(),
            code_changes: vec![
                patch_generator::CodeChange {
                    line_number: 1,
                    original_line: "fn main() { println!(\"hello\"); }".to_string(),
                    new_line: "fn main() { println!(\"hello, world!\"); }".to_string(),
                    change_type: patch_generator::ChangeType::Modification,
                }
            ],
            description: "Simple change".to_string(),
            confidence: 0.9,
            safety_analysis: patch_generator::SafetyAnalysis {
                is_safe: true,
                breaking_changes: vec![],
                security_risks: vec![],
                performance_impact: patch_generator::PerformanceImpact::Neutral,
            },
            breaking_changes: vec![],
            dependencies: vec![],
            test_requirements: vec![],
        };
        
        let result = validator.validate_patch(&patch, dir.path());
        assert!(result.is_ok());
    }

    #[test]
    fn test_database_integration() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let config = Config {
            llm_provider: "openai".to_string(),
            openai_api_key: Some("test-key".to_string()),
            anthropic_api_key: None,
            local_model_path: None,
            max_retries: 3,
            timeout_seconds: 30,
            safety_checks: true,
            auto_approve: false,
            webhook_url: None,
            slack_webhook: None,
            discord_webhook: None,
            email_notifications: false,
            prometheus_port: 9090,
            log_level: "info".to_string(),
            database_url: format!("sqlite:{}", db_path.to_string_lossy()),
            cache_dir: dir.path().join("cache").to_string_lossy().to_string(),
            max_cache_size_mb: 100,
            rate_limit: 10,
            enable_security_scanning: true,
            enable_performance_monitoring: true,
            enable_dependency_analysis: true,
            enable_rollback: true,
            enable_notifications: true,
            enable_webhooks: true,
            enable_prometheus: true,
            enable_grafana: true,
            enable_jaeger: true,
            enable_opentelemetry: true,
            enable_docker: true,
            enable_kubernetes: true,
            enable_helm: true,
            enable_terraform: true,
            enable_ansible: true,
            enable_chef: true,
            enable_puppet: true,
            enable_salt: true,
            enable_consul: true,
            enable_vault: true,
            enable_nomad: true,
            enable_prometheus_operator: true,
            enable_grafana_operator: true,
            enable_jaeger_operator: true,
            enable_opentelemetry_operator: true,
            enable_cert_manager: true,
            enable_ingress_nginx: true,
            enable_external_dns: true,
            enable_cluster_autoscaler: true,
            enable_metrics_server: true,
            enable_vertical_pod_autoscaler: true,
            enable_horizontal_pod_autoscaler: true,
            enable_pod_disruption_budget: true,
            enable_network_policies: true,
            enable_pod_security_policies: true,
            enable_pod_security_standards: true,
            enable_gatekeeper: true,
            enable_kyverno: true,
            enable_falco: true,
            enable_trivy: true,
            enable_anchore: true,
            enable_snyk: true,
            enable_grype: true,
            enable_clair: true,
            enable_docker_bench: true,
            enable_kube_bench: true,
            enable_kube_hunter: true,
            enable_kube_audit: true,
            enable_kube_leak: true,
            enable_kube_score: true,
            enable_kube_linter: true,
            enable_kube_conform: true,
            enable_kube_val: true,
            enable_kube_no_trouble: true,
            enable_kube_psp: true,
            enable_kube_warden: true,
            enable_kube_policy: true,
            enable_kube_guard: true,
        };

        let system = SelfHealingSystem::new(config).unwrap();
        let db = system.database;
        
        // Test storing and retrieving data
        let record = database::PatchRecord {
            id: "test-patch".to_string(),
            build_id: "build-123".to_string(),
            target_file: "src/main.rs".to_string(),
            patch_content: "test patch".to_string(),
            status: database::PatchStatus::Generated,
            confidence: 0.9,
            created_at: chrono::Utc::now(),
            applied_at: None,
            validation_result: None,
            rollback_info: None,
        };
        
        db.store_patch(&record).unwrap();
        let retrieved = db.get_patch("test-patch").unwrap();
        assert!(retrieved.is_some());
        assert_eq!(retrieved.unwrap().id, "test-patch");
    }

    #[test]
    fn test_monitoring_integration() {
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let config = Config {
            llm_provider: "openai".to_string(),
            openai_api_key: Some("test-key".to_string()),
            anthropic_api_key: None,
            local_model_path: None,
            max_retries: 3,
            timeout_seconds: 30,
            safety_checks: true,
            auto_approve: false,
            webhook_url: None,
            slack_webhook: None,
            discord_webhook: None,
            email_notifications: false,
            prometheus_port: 9090,
            log_level: "info".to_string(),
            database_url: format!("sqlite:{}", db_path.to_string_lossy()),
            cache_dir: dir.path().join("cache").to_string_lossy().to_string(),
            max_cache_size_mb: 100,
            rate_limit: 10,
            enable_security_scanning: true,
            enable_performance_monitoring: true,
            enable_dependency_analysis: true,
            enable_rollback: true,
            enable_notifications: true,
            enable_webhooks: true,
            enable_prometheus: true,
            enable_grafana: true,
            enable_jaeger: true,
            enable_opentelemetry: true,
            enable_docker: true,
            enable_kubernetes: true,
            enable_helm: true,
            enable_terraform: true,
            enable_ansible: true,
            enable_chef: true,
            enable_puppet: true,
            enable_salt: true,
            enable_consul: true,
            enable_vault: true,
            enable_nomad: true,
            enable_prometheus_operator: true,
            enable_grafana_operator: true,
            enable_jaeger_operator: true,
            enable_opentelemetry_operator: true,
            enable_cert_manager: true,
            enable_ingress_nginx: true,
            enable_external_dns: true,
            enable_cluster_autoscaler: true,
            enable_metrics_server: true,
            enable_vertical_pod_autoscaler: true,
            enable_horizontal_pod_autoscaler: true,
            enable_pod_disruption_budget: true,
            enable_network_policies: true,
            enable_pod_security_policies: true,
            enable_pod_security_standards: true,
            enable_gatekeeper: true,
            enable_kyverno: true,
            enable_falco: true,
            enable_trivy: true,
            enable_anchore: true,
            enable_snyk: true,
            enable_grype: true,
            enable_clair: true,
            enable_docker_bench: true,
            enable_kube_bench: true,
            enable_kube_hunter: true,
            enable_kube_audit: true,
            enable_kube_leak: true,
            enable_kube_score: true,
            enable_kube_linter: true,
            enable_kube_conform: true,
            enable_kube_val: true,
            enable_kube_no_trouble: true,
            enable_kube_psp: true,
            enable_kube_warden: true,
            enable_kube_policy: true,
            enable_kube_guard: true,
        };

        let system = SelfHealingSystem::new(config).unwrap();
        let monitoring = system.monitoring;
        
        // Test metrics collection
        monitoring.record_build_failure("test-build", "compilation");
        monitoring.record_patch_generated("test-patch", 0.9);
        monitoring.record_patch_applied("test-patch", true);
        
        let metrics = monitoring.get_metrics();
        assert!(metrics.build_failures_total > 0);
        assert!(metrics.patches_generated_total > 0);
        assert!(metrics.patches_applied_total > 0);
    }

    #[test]
    fn test_concurrent_operations() {
        use std::thread;
        
        let dir = tempdir().unwrap();
        let db_path = dir.path().join("test.db");
        let config = Config {
            llm_provider: "openai".to_string(),
            openai_api_key: Some("test-key".to_string()),
            anthropic_api_key: None,
            local_model_path: None,
            max_retries: 3,
            timeout_seconds: 30,
            safety_checks: true,
            auto_approve: false,
            webhook_url: None,
            slack_webhook: None,
            discord_webhook: None,
            email_notifications: false,
            prometheus_port: 9090,
            log_level: "info".to_string(),
            database_url: